
.ORIG x3000
;----------------------------------------
; EXAMPLE: LETTER OR DIGIT?
;----------------------------------------
START
  LEA R0, INPUT_PROMPT;
  PUTS;
  GETC; GET A CHARACTER INTO R0
  OUT; ECHO IT BACK OUT
  
  ; R0 NOW HAS THE USER-ENTERED CHARACTER WE NEED TO TEST...
  
IS_R0_UPPER; IS THE CHARACTER IN R0 AN UPPER CASE LETTER?
  LD R1, NEGATIVE_UPR_A_CHR; LOAD "A"
  ; IS R0 < A?
  ADD R1, R1, R0;
  BRN IS_R0_DIGIT; IF THE ADD PRODUCED A NEGATIVE NUMBER, THEN R0 IS A CHARACTER 'BELOW' A, SO IT *COULD* BE A DIGIT; LET'S GO FIND OUT...
  ; ELSE IT COULD STILL BE IN A-Z... LET'S SEE IF IT IS <= "Z"
  ; IS R0 > Z?
  LD R1, NEGATIVE_UPR_Z_CHR; LOAD "Z"
  ADD R1, R1, R0;
  BRP IS_R0_LOWER; IF THE ADD PRODUCED A POSITIVE NUMBER, THEN R0 IS A CHARACTER 'ABOVE' Z, SO IT *COULD* BE A LOWER CASE LETTER, BUT IT CANNOT BE A-Z AND IT CANNOT BE 0-9; LET'S GO FIND OUT IF IT IS A-Z
  ; ELSE WE KNOW IT IS BETWEEN A-Z INCLUSIVE, SO IT MUST BE AN UPPER CASE LETTER
  LEA R0, CONFIRM_UPPER_LETTER;
  PUTS
  BR START; REPEAT
  

IS_R0_LOWER; IS THE CHARACTER IN R0 A LOWER CASE LETTER? (IF WE GOT THIS FAR WE KNOW IT IS NOT A-Z)
  LD R1, NEGATIVE_LWR_A_CHR; LOAD "A"
  ; IS R0 < A?
  ADD R1, R1, R0;
  BRN IS_R0_DIGIT; IF THE ADD PRODUCED A NEGATIVE NUMBER, THEN R0 IS A CHARACTER 'BELOW' A , BUT ABOVE A, SO IT *CANNOT* BE A-Z OR A DIGIT, BECAUSE WE WOULD NOT HAVE GOTTEN THIS FAR; MUST NOT BE A VALID CHARACTER
  ; ELSE IT COULD STILL BE IN A-Z... LET'S SEE IF IT IS <= "Z"
  ; IS R0 <= Z?
  LD R1, NEGATIVE_LWR_Z_CHR; LOAD "Z"
  ADD R1, R1, R0;
  BRP IS_R0_OTHER; IF THE ADD PRODUCED A POSITIVE NUMBER, THEN R0 IS A CHARACTER 'ABOVE' Z, SO IT CANNOT BE A-Z EITHER... MUST BE OTHER
  ; ELSE WE KNOW IT IS BETWEEN A-Z INCLUSIVE, SO IT MUST BE AN LOWER CASE LETTER
  LEA R0, CONFIRM_LOWER_LETTER;
  PUTS
  BR START; REPEAT

IS_R0_DIGIT; IF WE GOT THIS FAR, IT *MAY BE* A DIGIT, BUT WE NEED TO VERIFY
  LD R1, NEGATIVE_0_CHR; LOAD "0"
  ; IS R0 < 0?
  ADD R1, R1, R0;
  BRN IS_R0_OTHER; IF THE ADD PRODUCED A NEGATIVE NUMBER, THEN R0 IS A CHARACTER 'BELOW' 0 , SO IT MUST BE "OTHER"
  ; ELSE IT COULD STILL BE IN 0-9... LET'S SEE IF IT IS <= "9"
  ; IS R0 <= 9?
  LD R1, NEGATIVE_9_CHR; LOAD "9"
  ADD R1, R1, R0;
  BRP IS_R0_OTHER; IF THE ADD PRODUCED A POSITIVE NUMBER, THEN R0 IS A CHARACTER 'ABOVE' 9, SO IT CANNOT BE 0-9 EITHER... MUST BE OTHER
  ; ELSE WE KNOW IT IS BETWEEN 0-9 INCLUSIVE, SO IT MUST BE A NUMBER
  LEA R0, CONFIRM_DIGIT;
  PUTS
  BR START; REPEAT

IS_R0_OTHER; IF WE GOT THIS FAR, IT DEFINITELY IS NOT A LETTER OR DIGIT
  LEA R0, CONFIRM_OTHER;
  PUTS
  BR START; REPEAT

  
HALT; NEVER GETS HERE... BUT JUST IN CASE!

INPUT_PROMPT .STRINGZ "\NPLEASE ENTER ANY CHARACTER:\N"
CONFIRM_UPPER_LETTER .STRINGZ "\NTHAT IS AN UPPER CASE LETTER!\N";
CONFIRM_LOWER_LETTER .STRINGZ "\NTHAT IS A LOWER CASE LETTER!\N";
CONFIRM_DIGIT .STRINGZ "\NTHAT IS A NUMERIC DIGIT!\N";
CONFIRM_OTHER .STRINGZ "\NTHAT IS NOT A LETTER OR A DIGIT\N";

NEGATIVE_UPR_A_CHR .FILL #-65;  CHAR "A" ASCII CODE, NEGATED
NEGATIVE_UPR_Z_CHR .FILL #-90;  CHAR "Z" ASCII CODE, NEGATED

NEGATIVE_LWR_A_CHR .FILL #-97;  CHAR "A" ASCII CODE, NEGATED
NEGATIVE_LWR_Z_CHR .FILL #-122;  CHAR "Z" ASCII CODE, NEGATED

NEGATIVE_0_CHR .FILL #-48; CHAR "0" ASCII CODE, NEGATED
NEGATIVE_9_CHR .FILL #-57; CHAR "9" ASCII CODE, NEGATED


.END
        